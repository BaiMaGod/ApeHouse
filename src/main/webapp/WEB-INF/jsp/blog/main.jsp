<%@ page language="java" contentType="text/html; charset=UTF-8"
	pageEncoding="UTF-8"%>
<%@include file="/WEB-INF/jsp/blog/head.jsp"%>

<a href="blog/detail?id=1560515142300552892394" class="btn btn-outline-secondary">阅读全文<i class="fa fa-angle-double-right btn-sm"></i></a>

	<h4 id="h4-2019-3-20-"><a name="2019年3月末考的三级数据库，在考前还有些紧张，但考试开始后，却异常轻松，因为每道题都异常熟悉、简单！选择填空不到20分钟就做完了。" class="reference-link"></a><span class="header-link octicon octicon-link"></span>2019年3月末考的三级数据库，在考前还有些紧张，但考试开始后，却异常轻松，因为每道题都异常熟悉、简单！选择填空不到20分钟就做完了。</h4><h4 id="h4--"><a name="当然我知道，这与我考试之前高强度的复习是离不开的。" class="reference-link"></a><span class="header-link octicon octicon-link"></span>当然我知道，这与我考试之前高强度的复习是离不开的。</h4><h5 id="h5--"><a name="在考前一个月，我开始仔细看三级数据库教程，当然，看完之后记住得不多（可以说少得可怜，仅仅对各种概念有些印象，根本说不出来）" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在考前一个月，我开始仔细看三级数据库教程，当然，看完之后记住得不多（可以说少得可怜，仅仅对各种概念有些印象，根本说不出来）</h5><h5 id="h5--7-19-20-"><a name="在考前一周，我开始着重做题，日夜做题，7天内做了19套三级数据库真题、20多套模拟测试题，每做完一套，我都会仔细理解错题，并将其中的知识点记录下来。" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在考前一周，我开始着重做题，日夜做题，7天内做了19套三级数据库真题、20多套模拟测试题，每做完一套，我都会仔细理解错题，并将其中的知识点记录下来。</h5><h6 id="h6--30-40-50-60-70-"><a name="就这样，从一开始模拟测试的30分、40分，到后来的50分、60分（只做选择填空，总分70）" class="reference-link"></a><span class="header-link octicon octicon-link"></span>就这样，从一开始模拟测试的30分、40分，到后来的50分、60分（只做选择填空，总分70）</h6><h6 id="h6--"><a name="这一过程的辛酸，只有自己能体会，不过收获与付出成正比，在离开考场的那一刻，我感觉整个人神清气爽，仿佛身上的枷锁瞬间打开，很舒畅。" class="reference-link"></a><span class="header-link octicon octicon-link"></span>这一过程的辛酸，只有自己能体会，不过收获与付出成正比，在离开考场的那一刻，我感觉整个人神清气爽，仿佛身上的枷锁瞬间打开，很舒畅。</h6><h6 id="h6--"><a name="下面是我根据做了的数十套三级数据库试题总结的常考、易错知识点，而且重点术语做了标记。" class="reference-link"></a><span class="header-link octicon octicon-link"></span>下面是我根据做了的数十套三级数据库试题总结的常考、易错知识点，而且重点术语做了标记。</h6><p>（我自己原本用的有道云笔记写的，关键词字体放大且涂了不同的眼色，以便记忆，不过csdn只有一种眼色，只有加粗不能设置字体大小，且不能自由排版，这是没办法的..）</p>
<hr>
<p>系统规划与定义：<br>1.内容包括：<br>            ==<strong>任务陈述、</strong><br>            <strong>确定任务目标、<br>            确定系统范围和边界、<br>            确定用户视图</strong>== </p>
<p>数据库 ==<strong>应用系统</strong>== 的需求分析：<br>1.包括<br>           ==<strong>数据需求分析</strong>== 、<br>            ==<strong>功能需求分析</strong>==（ ==<strong>数据处理</strong>== 需求分析、==<strong>业务规则</strong>== 需求分析）、<br>             ==<strong>性能需求</strong>== 分析（数据操作或数据访问 ==<strong>响应时间</strong>== 、系统 ==<strong>吞吐量</strong>==、允许 ==<strong>并发访问</strong>== 的最大用户数、==<strong>每秒TPS代价值</strong>==）、<br>            其他需求分析（==<strong>存储需求</strong>== 分析、==<strong>安全性需求</strong>== 分析、==<strong>备份和恢复需求</strong>== 分析）<br>2.过程：<br>           <strong>标识</strong>问题<br>        <strong>建立需求模型</strong><br>        <strong>描述</strong>需求<br>        <strong>确认</strong>需求</p>
<p>需求建模方法：<br>1.DFD：自顶向下 逐步细化  结构化分析方法<br>        4种基本元素：<br>                ==<strong>数据流：：箭头<br>                处理：：矩形<br>                数据存储：：圆角矩形<br>                外部项：：平行四边形</strong>==<br>2.IDEFO：自顶向下  结构化分析<br>    2种基本元素：<br>            ==<strong>矩形框：：功能活动<br>            箭头：左输入  右输出  上控制  下机制</strong>==<br>3.UML：面向对象思想</p>
<p>数据库 ==<strong>应用系统设计</strong>==：<br>一、<strong>概念设计</strong>：</p>
<p>二、<strong>逻辑设计</strong>阶段：<br>1.三部分工作：==<strong>数据库逻辑结构</strong>== 设计、==<strong>数据库事务概要</strong>== <em>设计、==<strong>应用程序概要</strong>== 设计<br>三、<strong>物理设计</strong>阶段：<br>1.主要活动：确定 ==<strong>存储结构</strong>==、==<strong>存取路径</strong>== 的选择和调整、确定 ==<strong>数据存放</strong>== 位置和确定 ==<em>*存储分配</em></em>==。（事务详细编码设计）</p>
<p>数据库物理设计：<br>1.包括：<br>    <strong>数据库逻辑模式</strong>描述、<br>    <strong>文件组织与存取</strong>设计、<br>    <strong>数据分布设计</strong>、<br>    确定<strong>系统配置</strong>、<br>    <strong>物理模式评估</strong>。</p>
<p>数据建模方法：<br>1.ER图<br>     实体：矩形框<br>     属性：圆角矩形<br>     关系：菱形<br>2.IDEF1X<br>元素：<br>实体集、（<br><strong>独立实体集 ：矩形框<br>从属实体集 ：圆角矩形</strong><br>）<br>联系、（<br><strong>标定型联系 ：双亲唯一确定，实线<br>==非标定型联系 ：一对多，虚线==<br>分类联系 ：同一类<br>非确定联系 ： 多对多</strong><br>）<br>==<strong>多对多联系为非确定联系</strong>==，</p>
<p>数据库应用系统实现与部署:<br>1.内容包括<br>①建立数据库结构<br>②数据加载<br>③事务和应用程序的编码及测试<br>④系统集成、测试与试运行<br>⑤系统部署。：</p>
<p>UML:<br>1.<strong>最基本的元素：事物</strong><br>2.UML语义的四层建模概念框架分别是：==<strong>元元模型层、元模型层、模型层、用户模型层</strong>==。<br>3.用例之间的三种关系：==<strong>扩展、使用、组合</strong>==<br>4.用例图：<strong>角色</strong>是与系统进行交互的 ==<strong>外部实体</strong>==</p>
<p>SQL Server 约束：<br>1.五种约束类型：==<strong>主键约束、外键约束、唯一性约束、缺省约束，检查约束</strong>==。<br>2.数据库完整性约束条件的作用对象 ==<strong>列、元组、关系</strong>== 三种级别。<br>3.数据库完整性 指：<br>==<strong>正确性、一致性、相容性</strong>==<br>4.<strong>实体完整</strong>性：定义主码  等<br>5.<strong>参照完整</strong>性：用FOREIGN KEY短语定义哪些列为外码，用REFERENCES短语指明这些外码参照哪些表的主码。<br>6.<strong>用户自定义完整</strong>性：列值非空（NOT NULL），列值唯一（UNIQUE），检查列值是否满足一个布尔表达式（CHECK短语）。</p>
<p>事务：<br>1.==<strong>数据库吞吐量</strong>== 指的是系统在单位时间可以完成的数据库事务数量。<br>2.加锁协议中 ==<strong>两阶段加锁协议</strong>== 可以保证事务调度 ==<strong>可串行性</strong>== 。<br>3.事务规范包括：<strong>事务名称、事务描述、事务所访问的数据项、事务用户</strong><br>4.事务概要设计内容包括：事务名称、事务所访问的关系表及关系属性、事务处理逻辑、事务用户（指使用、启动、调用该事务的软件模块或系统）<br>5.检测死锁:==<strong>超时法、等待图法</strong>==<br>6.==<strong>非预期</strong>== 的事务内部故障：指不能由事务程序处理的，<br>如运算溢出故障、<br>并发事务死锁故障、<br>违反了某些完整性限制而导致的故障等。</p>
<p>sql：<br>1.写的顺序：select … from… where…. group by… having… order by..<br>执行顺序：from… where…group by… having…. select … order by…<br>2.like匹配<br>下划线 ==<strong>_</strong>== ：匹配任意一个字符<br>百分号 ==<strong>%</strong>== ：匹配0到多个字符<br>方括号  ==<strong>[ ]</strong>== ：转义<br>尖号  ==<strong>^</strong>== ：排除一些字符进行匹配。</p>
<p>t-sql:<br>1.将T1表中的全部数据复制到T2表中，<br>    <strong>T2表已存在: INSERT INTO T2 SELECT <em> FROM T1<br>    T1表不存在： SELECT </em>  INTO T2 FROM T1</strong></p>
<p>索引：<br>1.<br>CREATE [<strong>UNIQUE</strong>] [<strong>CLUSTERED</strong> | NONCLUSTERED] INDEX index_name<br>ON table(column)</p>
<p>触发器：<br>1.DML触发器有三类：① ==<strong>INSERT</strong>== 触发器；② ==<strong>UPDATE</strong>== 触发器；③ ==<strong>DELETE</strong>== 触发器。<br>2.==<strong>DELETED表</strong>== 用于存储 ==<strong>更新前</strong>== 数据，==<strong>INSERTED表</strong>== 用于 ==<strong>更新后</strong>== 的数据。<br>3.<strong>一张表</strong>上的同一操作，可以建立<strong>多个后触发器</strong>，但只能建立 ==<strong>一个前触发器</strong>==。</p>
<ol>
<li><strong>创建</strong>触发器用<strong>CREATE</strong>:语句，<strong>修改</strong>触发器用<strong>ALTER</strong>语句，<strong>删除</strong>触发器用<strong>DROP</strong>语句。<br>  CREATE TRIGGER [schema<em>name] tri_1 ON {table | view} {FOR | AFTER | INSTEAD OF} {[INSERT] [,]  [UPDATE] [,] [DELETE]} AS {sql</em>语句}<br>修改触发器用ALTER:<br>删除触发器用DROP:DROP TRIGGER trigger_name<br>5.INSTEAD OF创建前触发器，FOR或AFTER创建后触发器。<br>6.CREATE TRIGGER tri_sales ON 销售表 FOR UPDATE … …</li></ol>
<p>函数：<br>1.三种用户自定义函数：<br>==<strong>标量函数</strong>==（SELECT目标列）<br>==<strong>内嵌表值函数</strong>==（SELECT语句的FROM子句中）<br>==<strong>多语句表值函数</strong>==（SELECT语句的FROM子句中）。<br>2.排名函数：<br>① ==<strong>rank（）</strong>== ：返回结果集的分区内每行排名，1开始<br>② ==<strong>dense_rank（）</strong>==：返回结果集分区中行的排名，排名中无间断，1开始<br>③ ==<strong>row_number()</strong>==:返回结果集分区内行的序号，每个分区从第一行开始<br>④ ==<strong>ntile（）</strong>==：将有序分区中的行分发到指定数目的组中  编号从1开始</p>
<p>游标：<br>1.游标指针各个参数含义：<br><strong>NEXT</strong>：返回紧跟在<strong>当前行之后的数据行</strong>，并且当前行<strong>递增</strong>为结果行。（==<strong>取下一行</strong>==）<br><strong>PRIOR</strong>：返回紧跟<strong>当前行前面的数据行</strong>，并且当前行<strong>递减</strong>为结果行。（==<strong>取上一行</strong>==）<br><strong>FIRST</strong>：返回游标中的 ==<strong>第一行</strong>== 并将其作为当前行。<br><strong>LAST</strong>：返回游标中的 ==<strong>最后一行</strong>== 并将其作为当前行。<br>2.判断游标提取状态的全局变量：==<strong>@<a href="https://github.com/FETCH_STATUS" title="&#64;FETCH_STATUS" class="at-link">@FETCH_STATUS</a></strong>==</p>
<p>权限：<br>1.三种权限管理：==<strong>GRANT（授权）</strong>==、==<strong>DENY（拒绝）</strong>==、==<strong>REVOKE（收回）</strong>==<br>2.==<strong>系统管理员角色是sysadmin</strong>==。</p>
<p>备份转储：<br>1.<strong>两种数据库备份</strong>：<br>==<strong>①完全备份</strong>==，备份所有数据和日志；<br>==<strong>②差异备份</strong>==，备份自上一次数据库完全备份以来变化的数据和日志。<br>2.==<strong>文件备份不备份日志</strong>==<br>3.将DB1数据库完整备份到BK设备上：<strong>BACKUP</strong> DATABASE DB1 TO BK<br>3.使用 ==<strong>DIFFERENTIAL</strong>== 关键词指定该备份为 ==<strong>差异备份</strong>==。</p>
<ol>
<li>==<strong>静态转储</strong>== 可以保证数据的 ==<strong>有效性</strong>==，但是却降低数据库的可用性，<br>==<strong>动态转储</strong>== 可以提高数据库的 ==<strong>可用性</strong>==，但数据的有效性得不到保证。<br><strong>为保证数据的一致性，需使用日志文件和动态转储结合使用</strong>。<br>5.===<strong>只有tempdb数据库不需要备份</strong>== ，其他的都需要备份。<br>6.事务日志备份并不备份数据库本身，它只备份日志记录，而且只备份从上次备份之后到当前备份时间 发生变化的日志内容<br>7.备份策略的制定包括：<br>定义备份的类型和频率、<br>备份所需硬件的特性和速度、<br>备份的测试方法<br>备份媒体的存储位置和方法。</li></ol>
<p>恢复：<br>1.数据仓库恢复模式：==<strong>简单恢复模式、完整恢复模式、大容量日志恢复模式</strong>==。<br>    <strong>简单恢复模式只用于测试和开发数据库</strong>，或用于主要包含<strong>只读数据的数据库</strong>（==<strong>如数据仓库</strong>==）==<strong>不复制日志</strong>==。<br>2.数据库恢复顺序：<br>（1）还原最新完整数据库备份而不恢复数据库。</p>
<p>（2）如果存在差异备份，则还原最新的差异备份而不恢复数据库。</p>
<p>（3）从最后一次还原备份后创建的第一个事务日志开始，使用NORECOVERY选项依次还原日志。</p>
<p>（4）还原数据库，此步骤也可以与还原上一次日志备份结合使用。<br>3.SQL Server 2008仅支持数据库、数据文件两个级别的数据恢复<br>4.检查点技术的最大特点是最大限度地减少了数据库完成恢复时所必须执行的日志部分。</p>
<p>分离数据库：<br>1.删除数据库在sql server中的实例，<strong>不删除数据文件</strong><br>2.分离数据库时需要<strong>停用被分离的数据库</strong>，但是 ==<strong>不需要停用SQL Server服务</strong>==。</p>
<p>运行管理与维护：<br>1.包括 ==<strong>日常维护、监控与分析、性能优化调整、系统进化</strong>==。<br>2.日常维护：==<strong>备份（转储）与恢复、完整性维护、安全性维护、存储空间管理和并发控制</strong>==。<br>3.监控：<strong>空间、缓冲、锁、回滚段、临时段、索引、用户连接</strong>（==<strong>不监控执行的语句！！</strong>==）<br>4.性能优化：<br>           <strong>运行环境</strong>（外部调整（CPU，网络）、内存、磁盘I/O）<br>            <strong>参数调整</strong>（控制最大进程数、减少进程竞争、减少多线程服务进程竞争、减少重做日志缓冲区竞争、减少回滚段竞争）<br>            <strong>模式调整</strong>（派生性冗余列、冗余列、重组表、分割表、新增汇总表）、<br>            <strong>存储优化</strong>（物化视图、聚集）、<br>            <strong>查询优化</strong>（索引、简化排序、使用临时表、存储过程、事务）</p>
<p>存储表数据的文件类型：<br>1.频繁对两个表进行<strong>关联查询</strong>，符合 ==<strong>聚集文件</strong>== 的特性<br>2.存储方式中，聚集就是将经常一起使用的多个表中的数据行按照其公共列值存储在一起。</p>
<p>OLAP:<br>1.OLAP多维分析 常用的5种操作：<strong>切片、切块、旋转、钻取、卷起</strong>。<br>2.三类实现技术：①基于<strong>关系</strong>型数据库的<strong>MOLAP</strong>；②基于<strong>多维</strong>数据库的<strong>ROLAP</strong>；③<strong>混合型HOLAP</strong></p>
<p>数据仓库：<br>1.在数据仓库中，元数据主要分为 ==<strong>技术元数据</strong>== 和 ==<strong>业务元数据</strong>== 两类。<br>2.知识发现过程由以下三个阶段组成：<strong>数据准备、数据挖掘、结果的解释和评估</strong></p>
<ol>
<li>ODS分类：<pre><code> 第一类ODS数据更新频率是**秒级，**
 第二类ODS的数据更新频率是**小时级**，
 第三类ODS的数据更新频率是**天级，**
 上述三类是根据数据更新速度划分的
 第四类ODS是根据数据**来源方向和类型划**分的。
</code></pre>3.在关联规则挖掘中：关联规则的成立与否一般用 ==<strong>支持度</strong>== 和 ==<strong>置信度</strong>== 两个指标进行描述。<br>4.在数据仓库的导出数据或物化视图实视图的维护策略中只在用户查询时发现数据已过期才更新的策略称为 <strong>==延时== 维护策略</strong>。  </li></ol>
<p>数据挖掘：<br>1.步骤：数据准备，数据挖掘，结果解释和评估<br>2.挖掘类型：<br><strong>关联规则挖掘</strong>（关联性，支持度，置信度）<br><strong>分类挖掘</strong>（两步骤：<br>分类函数，<br>分类器—&gt;统计方法，机器学习～，神经网络～）<br><strong>聚类挖掘</strong>（无监督，）<br>时间序列分析</p>
<p>分布式数据库：<br>1.分片是对关系的操作，而分配是对分片结果的操作。<br>2.==<strong>分片模式</strong>== 是描述每个数据片断以及<strong>全局关系到片段的映像</strong>，==<strong>分配模式</strong>== 是描述<strong>各片断到物理存放场地的映像</strong>。<br>3.四部分组成：==<strong>局部数据库管理系统 、全局数据库管理系统GDBMS、全局数据字典、通信管理</strong>==。<br>4.具有<strong>分布式透明性</strong>的主要因素：==<strong>位置独立性、数据分片独立性、数据复制独立性</strong>==</p>
<ol>
<li>==<strong>最基本特征</strong>==：==<strong>本地自治、非集中式管理、高可用性</strong>==。<br>6.<strong>分布透明性包括</strong>:==<strong>分片透明性、位置透明性、局部数据模型透明性</strong>==。<br>7.采用  <strong>==半== 连接</strong>操作可以减少场地之间的数据传输量。</li></ol>
<p>并行数据库：<br>1.一维数据的划分方法：<br>（1）==<strong>轮转法</strong>== ：最适合于<strong>扫描整个关系</strong>；<br>（2）==<strong>散列划分法</strong>== ：比转转法更适合<strong>点查询</strong>，也适合<em>顺序扫描</em>关系；<br>（3）==<strong>范围划分法</strong>== ：明显利于范围查询和点查询。会引起数据分布不均匀导致并行处理能力下降。<br>2.最基本特征：本地自治、非集中式管理、高可用性。<br>3.分布透明性包括:分片透明性、位置透明性、局部数据模型透明性。<br>7.采用  半 连接操作可以减少场地之间的数据传输量。</p>
<p>==<strong>BigTable</strong>== 数据模型:<br>1.特点是：<br>①表中的<strong>关键字</strong>可以是<strong>任意的字符串</strong>；<br>②列族是由列关键字组成的集合，是访问控制的基本单位；<br>③时间戳记录了BigTable是每一个数据项所包含的不同版本的数据的时间标识。<br>④可以随意增减行的数量<br>⑤每个单元格通过行关键字、列关键字和时间戳共同定位</p>
	


<%@include file="/WEB-INF/jsp/blog/foot.jsp"%>